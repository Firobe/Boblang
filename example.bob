(* Recursion stuff *)
Typemacro SELF tau = rec(t, (t -> tau))
Macro SELF [tau] expr = fold[SELF(tau)](fun (tmp : SELF(tau)) -> expr)
Macro UNROLL g =
     letr unf = comp(unfold(g)) in
     (unf . g)
Macro FIX [tau] x e =
     UNROLL(SELF[tau](SUBSTITUTE(x, UNROLL(tmp), e)))

(* Natural numbers definition *)
Type nat = rec(t, (1 + t))
Declare zero = fold[nat](left[(1 + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(1 + nat)](x)))

(* Some testing *)
Declare two = comp( letr one = comp((succ . zero)) in (succ . one))

Declare minus_one = fun (i : nat) ->
     letr unpacked = comp(unfold(i)) in
     case unpacked of
         left(_) -> ret(zero)
         right(pred) -> ret(pred)

Eval letr twu = two in (minus_one . twu)

(* An exciting recursive function ! *)
Declare double = FIX[(nat -> nat)](double,
 ret (fun (x : nat) ->
     letr x' = comp(unfold(x)) in
     case x' of
         left(_) -> ret(zero)
         right(e) ->
             letr frec = comp(double) in
             letr doubled = comp((frec . e)) in
             letr doubled' = comp((succ . doubled)) in
             letr doubled'' = comp((succ . doubled')) in
             ret (doubled'')
  ))

Check double

(* Wow, 2 * 2 = 4 *)
Eval
    letr twu = two in
    letr f = comp(double) in (f . twu)
