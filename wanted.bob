Type nat = rec(t, (1 + t))
Declare zero = fold[nat](left[(1 + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(1 + nat)](x)))

Declare two = comp(
    letr one = comp((succ . zero)) in (succ . one)
)

Declare minus_one = fun (i : nat) ->
     letr unpacked = comp(unfold(i)) in
     case unpacked of
         left(_) -> ret(zero)
         right(pred) -> ret(pred)

Typemacro SELF tau = rec(t, t -> tau)

Macro SELF tau x e = fold(SELF(tau), fun (x : SELF(tau)) -> e)
Macro UNROLL e =
     letr unf = comp(unfold(e)) in
     (unf . e)
Macro FIX tau x e =
     UNROLL(SELF(tau, tmp, SUBSTITUTE(x, UNROLL(tmp), e)))

Declare double = FIX(nat -> nat, double,
 ret (fun (x : nat) ->
     letr x' = comp(unfold(x)) in
     case x of
         left(_) -> ret(zero)
         right(e) ->
             letr frec = comp(double) in
             letr doubled = (frec . e) in
             letr doubled' = (succ . doubled) in
             letr doubled'' = (succ . doubled') in
             ret doubled''
  ))

Check double
Check (double . two)
Eval (double . two)
