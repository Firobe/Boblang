Bob libob.recursion
Bob libob.maybe
Bob libob.bool

Type nat = rec(n, (unit + n))
Declare 0 = fold[nat](left[(unit + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(unit + nat)](x)))

(* Some common numbers *)
Declare 1 = (succ 0)
Declare 2 = (succ 1)
Declare 3 = (succ 2)
Declare 4 = (succ 3)
Declare 5 = (succ 4)
Declare 6 = (succ 5)
Declare 7 = (succ 6)
Declare 8 = (succ 7)
Declare 9 = (succ 8)
Declare 10 = (succ 9)

(* Addition *)
Declare add = FIX[(nat -> (nat -> nat))](add, ret(
    fun (n1 : nat) -> ret(fun (n2 : nat) ->
        let* n1' = unfold(n1) in
        case n1' of
            left(_) -> ret(n2)
            right(n1'') ->
                let* n2' = (succ n2) in
                REC_CALL2(add, n1'', n2')
)))

(* Mutiplication *)
Declare mult = FIX[(nat -> (nat -> nat))](mult, ret(
    fun (n1 : nat) -> ret(fun (n2 : nat) ->
        let* n1' = unfold(n1) in
        case n1' of
            left(_) -> ret(0)
            right(n1'') ->
                C(CURRY2(add, n2, _), REC_CALL2(mult, n1'', n2))
)))

(* Subtraction *)
Declare sub = FIX[(nat -> (nat -> MAYBE(nat)))](sub, ret(
    fun (n1 : nat) -> ret(fun (n2 : nat) ->
        let* n2' = unfold(n2) in
        case n2' of
            left(_) (*zero*) -> ret(SOME[nat](n1))
            right(n2'') ->
                let* n1' = unfold(n1) in
                case n1' of
                    left(_) (* n1 < n2 *) -> ret(NONE[nat](()))
                    right(n1'') -> REC_CALL2(sub, n1'', n2'')
)))

(* >= *)
Declare geq = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* res = CURRY2(sub, n1, n2) in
    case res of
        left(_) (*some*) -> ret(true)
        right(_) (*none*) -> ret(false)
)
(* < *)
Declare lt = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* geq? = CURRY2(geq, n1, n2) in
    (not geq?)
)

(* Euclidian division (division on 0 will loop indefinitely) *)
Declare eucdiv = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* aux = FIX[(nat -> (nat -> (nat * nat)))](aux, ret(
        fun (rem : nat) -> ret(fun (res : nat) ->
            let* sub? = CURRY2(sub, rem, n2) in
            case sub? of
                left(next) (* some *) ->
                    let* nres = (succ res) in
                    REC_CALL2(aux, next, nres)
                right(_) (* none *) -> ret((rem, res))
    ))) in CURRY2(aux, n1, 0))

(* Division quotient *)
Declare div = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* dres = CURRY2(eucdiv, n1, n2) in
    lets (_, res) = dres in ret(res)
)
(* Remainder *)
Declare mod = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* dres = CURRY2(eucdiv, n1, n2) in
    lets (mod, _) = dres in ret(mod)
)
