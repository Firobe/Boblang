Bob libob.recursion
Bob libob.maybe
Bob libob.bool

Type nat = rec(n, (unit + n))
Declare 0 = fold[nat](left[(unit + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(unit + nat)](x)))

(* Addition *)
Declare add = FIX[(nat -> (nat -> nat))](add, ret(
    fun (n1 : nat) -> ret(fun (n2 : nat) ->
        let* n1' = unfold(n1) in
        case n1' of
            left(_) -> ret(n2)
            right(n1'') ->
                let* n2' = (succ n2) in
                REC_CALL2(add, n1'', n2')
)))

(* Mutiplication *)
Declare mult = FIX[(nat -> (nat -> nat))](mult, ret(
    fun (n1 : nat) -> ret(fun (n2 : nat) ->
        let* n1' = unfold(n1) in
        case n1' of
            left(_) -> ret(0)
            right(n1'') ->
                C(CURRY2(add, n2, _), REC_CALL2(mult, n1'', n2))
)))

(* Subtraction *)
Declare sub = FIX[(nat -> (nat -> MAYBE(nat)))](sub, ret(
    fun (n1 : nat) -> ret(fun (n2 : nat) ->
        let* n2' = unfold(n2) in
        case n2' of
            left(_) (*zero*) -> ret(SOME[nat](n1))
            right(n2'') ->
                let* n1' = unfold(n1) in
                case n1' of
                    left(_) (* n1 < n2 *) -> ret(NONE[nat])
                    right(n1'') -> REC_CALL2(sub, n1'', n2'')
)))

Declare equal = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* sub = CURRY2(sub, n1, n2) in
    case sub of
        left(n) (* some *) ->
            let* n = unfold(n) in
            case n of
                left(_) (* zero *) -> ret(true)
                right(_) -> ret(false)
        right(_) (* none *) -> ret(false)
)


(* >= *)
Declare geq = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* res = CURRY2(sub, n1, n2) in
    case res of
        left(_) (*some*) -> ret(true)
        right(_) (*none*) -> ret(false)
)
(* < *)
Declare lt = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* geq? = CURRY2(geq, n1, n2) in
    (not geq?)
)

(* Euclidian division (division on 0 will loop indefinitely) *)
Declare eucdiv = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* aux = FIX[(nat -> (nat -> (nat * nat)))](aux, ret(
        fun (rem : nat) -> ret(fun (res : nat) ->
            let* sub? = CURRY2(sub, rem, n2) in
            case sub? of
                left(next) (* some *) ->
                    let* nres = (succ res) in
                    REC_CALL2(aux, next, nres)
                right(_) (* none *) -> ret((rem, res))
    ))) in CURRY2(aux, n1, 0))

(* Division quotient *)
Declare div = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* dres = CURRY2(eucdiv, n1, n2) in
    lets (_, res) = dres in ret(res)
)
(* Remainder *)
Declare mod = fun (n1 : nat) -> ret(fun (n2 : nat) ->
    let* dres = CURRY2(eucdiv, n1, n2) in
    lets (mod, _) = dres in ret(mod)
)

(* Some common numbers *)
Declare 1 = (succ 0)
Declare 2 = (succ 1)
Declare 3 = (succ 2)
Declare 4 = (succ 3)
Declare 5 = (succ 4)
Declare 6 = (succ 5)
Declare 7 = (succ 6)
Declare 8 = (succ 7)
Declare 9 = (succ 8)
Declare 10 = (succ 9)
Declare 11 = (succ 10)
Declare 12 = (succ 11)
Declare 13 = (succ 12)
Declare 14 = (succ 13)
Declare 15 = (succ 14)
Declare 16 = (succ 15)
Declare 17 = (succ 16)
Declare 18 = (succ 17)
Declare 19 = (succ 18)
Declare 20 = (succ 19)
Declare 21 = (succ 20)
Declare 22 = (succ 21)
Declare 23 = (succ 22)
Declare 24 = (succ 23)
Declare 25 = (succ 24)
Declare 26 = (succ 25)
Declare 27 = (succ 26)
Declare 28 = (succ 27)
Declare 29 = (succ 28)
Declare 30 = (succ 29)
Declare 31 = (succ 30)
Declare 32 = (succ 31)
Declare 33 = (succ 32)
Declare 34 = (succ 33)
Declare 35 = (succ 34)
Declare 36 = (succ 35)
Declare 37 = (succ 36)
Declare 38 = (succ 37)
Declare 39 = (succ 38)
Declare 40 = (succ 39)
Declare 41 = (succ 40)
Declare 42 = (succ 41)
Declare 43 = (succ 42)
Declare 44 = (succ 43)
Declare 45 = (succ 44)
Declare 46 = (succ 45)
Declare 47 = (succ 46)
Declare 48 = (succ 47)
Declare 49 = (succ 48)
Declare 50 = (succ 49)
Declare 51 = (succ 50)
Declare 52 = (succ 51)
Declare 53 = (succ 52)
Declare 54 = (succ 53)
Declare 55 = (succ 54)
Declare 56 = (succ 55)
Declare 57 = (succ 56)
Declare 58 = (succ 57)
Declare 59 = (succ 58)
Declare 60 = (succ 59)
Declare 61 = (succ 60)
Declare 62 = (succ 61)
Declare 63 = (succ 62)
Declare 64 = (succ 63)
Declare 65 = (succ 64)
Declare 66 = (succ 65)
Declare 67 = (succ 66)
Declare 68 = (succ 67)
Declare 69 = (succ 68)
Declare 70 = (succ 69)
Declare 71 = (succ 70)
Declare 72 = (succ 71)
Declare 73 = (succ 72)
Declare 74 = (succ 73)
Declare 75 = (succ 74)
Declare 76 = (succ 75)
Declare 77 = (succ 76)
Declare 78 = (succ 77)
Declare 79 = (succ 78)
Declare 80 = (succ 79)
Declare 81 = (succ 80)
Declare 82 = (succ 81)
Declare 83 = (succ 82)
Declare 84 = (succ 83)
Declare 85 = (succ 84)
Declare 86 = (succ 85)
Declare 87 = (succ 86)
Declare 88 = (succ 87)
Declare 89 = (succ 88)
Declare 90 = (succ 89)
Declare 91 = (succ 90)
Declare 92 = (succ 91)
Declare 93 = (succ 92)
Declare 94 = (succ 93)
Declare 95 = (succ 94)
Declare 96 = (succ 95)
Declare 97 = (succ 96)
Declare 98 = (succ 97)
Declare 99 = (succ 98)
Declare 100 = (succ 99)
Declare 101 = (succ 100)
Declare 102 = (succ 101)
Declare 103 = (succ 102)
Declare 104 = (succ 103)
Declare 105 = (succ 104)
Declare 106 = (succ 105)
Declare 107 = (succ 106)
Declare 108 = (succ 107)
Declare 109 = (succ 108)
Declare 110 = (succ 109)
Declare 111 = (succ 110)
Declare 112 = (succ 111)
Declare 113 = (succ 112)
Declare 114 = (succ 113)
Declare 115 = (succ 114)
Declare 116 = (succ 115)
Declare 117 = (succ 116)
Declare 118 = (succ 117)
Declare 119 = (succ 118)
Declare 120 = (succ 119)
Declare 121 = (succ 120)
Declare 122 = (succ 121)
Declare 123 = (succ 122)
Declare 124 = (succ 123)
Declare 125 = (succ 124)
Declare 126 = (succ 125)
Declare 127 = (succ 126)
