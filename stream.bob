(* ================ RECURSION ==================== *)

Typemacro SELF tau = rec(t, (t -> tau))
Macro SELF [tau] expr = fold[SELF(tau)](fun (tmp : SELF(tau)) -> expr)
Macro UNROLL g =
     let* unf = unfold(g) in
     (unf . g)
Macro FIX [tau] x e =
     UNROLL(SELF[tau](SUBSTITUTE(x, UNROLL(tmp), e)))

(* ================== NAT ====================== *)

Type nat = rec(t, (1 + t))
Declare zero = fold[nat](left[(1 + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(1 + nat)](x)))

(* ================== BOOL ====================== *)

Type bool = (1 + 1)
Declare true = left[bool]( () )
Declare false = right[bool]( () )

Declare flip = fun (x : bool) ->
    case x of
        left(_) (* true *) -> ret (false) (* lambdas should return lazyutations *)
        right(_) (* false *) -> ret (true)

(* ================ BOOL LIST ================ *)

Type blist = rec(t, (1 + (bool * t)))
Declare nil = fold[blist](left[(1 + (bool * blist))](()))
Declare cons =
    fun (x : bool) -> ret (
        fun (l : blist) -> ret (
            fold[blist](right[(1 + (bool * blist))]((x ,l)))
        )
    )

(* ================ STREAMS ==================== *)

Type stream = rec(t, (bool * lazy(t)))
Declare push =
    fun (x : bool) -> ret (
        fun (s : lazy(stream)) -> ret (
            fold[stream]((x, s))
        )
    )

Declare take = FIX[(nat -> (stream -> blist))](take,
ret(
    fun (n : nat) -> ret (
        fun (s : stream) ->
            let* n' = unfold(n) in
            case n' of
                left(_) -> ret(nil)
                right(e) ->
                    let* s' = unfold(s) in
                    lets (x, rest) = s' in
                    let* f = take in
                    let* f' = (f . e) in
                    let* rrest = force(rest) in
                    let* res = (f' . rrest) in
                    let* c' = (cons . x) in
                    (c' . res)
        )
    )
)

Declare zeros = FIX[stream](zeros,
    let* p' = (push . false) in
    (p' . lazy(zeros)) 
)

Declare map = FIX[((bool -> bool) -> (stream -> stream))](map,
ret(
    fun (f : (bool -> bool)) -> ret(
        fun (s : stream) ->
            let* s' = unfold(s) in
            lets (x, rest) = s' in
            let* rest' = force(rest) in
            let* fapp = (f . x) in
            let* frec = map in
            let* frec' = (frec . f) in
            let* push' = (push . fapp) in
            (push' . lazy((frec' . rest')))
    )
))

Declare merge = FIX[(stream -> (stream -> stream))](merge,
ret (
    fun (s1 : stream) -> ret (
        fun (s2 : stream) ->
            let* s1' = unfold(s1) in
            let* s2' = unfold(s2) in
            lets (x1, rest1) = s1' in
            lets (x2, rest2) = s2' in
            let* rest1' = force(rest1) in
            let* rest2' = force(rest2) in
            let* frec = merge in
            let* frec' = (frec . rest1') in
            let* push' = (push . x2) in
            let* push''' = (push . x1) in
            (push''' . lazy((push' . lazy((frec' . rest2')))))
    )
))

(* ========================= TESTING ======================== *)

Declare one = (succ . zero)
Declare two = let* one' = one in (succ . one')

Macro TAKETWO s =
    let* f = take in
    let* two' = two in
    let* f' = (f. two') in
    let* z' = s in
    (f' . z')

(* take 2 zeros *)
Eval TAKETWO(zeros)

(* map flip on zeros *)
Declare ones =
    let* map' = map in
    let* zeros' = zeros in
    let* f' = (map' . flip) in
    (f' . zeros')

(* take 2 ones *)
Eval TAKETWO(ones)

Declare alternating =
    let* merge' = merge in
    let* zeros' = zeros in
    let* ones' = ones in
    let* app = (merge' . zeros') in
    (app . ones')

(* take 2 alternating *)
Eval TAKETWO(alternating)
