Bob libob.nat
Bob libob.list
Bob libob.print
Bob libob.recursion

(* ================ STREAMS ==================== *)

Typemacro STREAM tau = rec(t, (tau * lazy(t)))

Macro SPUSH [tau] =
    fun (x : tau) -> ret (
        fun (s : lazy(STREAM(tau))) -> ret (
            fold[STREAM(tau)]((x, s))
        )
    )

Macro SPOP [tau] = fun (s : STREAM(tau)) ->
    let* c = unfold(s) in
    lets (x, rest) = c in
    let* next = force(rest) in
    ret((x, next))

Macro STAKE [tau] = FIX[(nat -> (STREAM(tau) -> LIST(tau)))](take,
ret(
    fun (n : nat) -> ret (
        fun (s : STREAM(tau)) ->
            let* n' = unfold(n) in
            case n' of
                left(_) -> ret(NIL[tau])
                right(e) ->
                    let* s' = (SPOP[tau] s) in
                    lets (x, rest) = s' in 
                    let* res = REC_CALL2(take, e, s) in
                    CURRY2(CONS[tau], false, res)
        )
    )
)

Macro SMAP [tau] = FIX[((tau -> tau) -> (STREAM(tau) -> STREAM(tau)))](map,
ret(
    fun (f : (tau -> tau)) -> ret(
        fun (s : STREAM(tau)) ->
            let* s' = (SPOP[tau] s) in
            lets (x, rest) = s' in
            let* push_new = C((SPUSH[tau] _), (f x)) in
            let* rec_map = REC_CALL(map, f) in
            (push_new lazy((rec_map rest)))
    )
))

Macro SMERGE [tau] = FIX[(STREAM(tau) -> (STREAM(tau) -> STREAM(tau)))](merge,
ret (
    fun (s1 : STREAM(tau)) -> ret (
        fun (s2 : STREAM(tau)) ->
            let* s1' = (SPOP[tau] s1) in
            let* s2' = (SPOP[tau] s2) in
            lets (x1, rest1) = s1' in
            lets (x2, rest2) = s2' in
            let* frec' = REC_CALL(merge, rest1) in
            let* push' = (SPUSH[tau] x2) in
            let* push''' = (SPUSH[tau] x1) in
            (push''' lazy((push' lazy((frec' rest2)))))
    )
))


(* ========================= TESTING ======================== *)

Declare 0s = FIX[STREAM(nat)](0s,
    CURRY2(SPUSH[nat], 0, lazy(0s))
)

Declare stake = STAKE[nat]

(* take 2 0s *)
Eval CURRY2(stake, 2, 0s)

(* map flip on 0s *)
Declare 1s =
    C((_ 0s), (map not))

(* take 2 1s *)
Eval TAKE2(1s)

Declare alternating =
    C((_ 1s), (merge 0s))

(* take 2 alternating *)
Eval TAKE2(alternating)
