Macro C e v = let* _ = v in e (* EASY CHAINING *)

(* ================ RECURSION ==================== *)

Typemacro SELF tau = rec(t, (t -> tau))
Macro SELF [tau] expr = fold[SELF(tau)](fun (tmp : SELF(tau)) -> expr)
Macro UNROLL g =
     let* unf = unfold(g) in
     (unf g)
Macro FIX [tau] x e =
     UNROLL(SELF[tau](SUBSTITUTE(x, UNROLL(tmp), e)))

(* ================== NAT ====================== *)

Type nat = rec(t, (unit + t))
Declare 0 = fold[nat](left[(unit + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(unit + nat)](x)))

(* ================== BOOL ====================== *)

Type bool = (unit + unit)
Declare true = left[bool]( () )
Declare false = right[bool]( () )

Declare flip = fun (x : bool) ->
    case x of
        left(_) (* true *) -> ret (false) (* lambdas should return computations *)
        right(_) (* false *) -> ret (true)

(* ================ BOOL LIST ================ *)

Type blist = rec(t, (unit + (bool * t)))
Declare nil = fold[blist](left[(unit + (bool * blist))](()))
Declare cons =
    fun (x : bool) -> ret (
        fun (l : blist) -> ret (
            fold[blist](right[(unit + (bool * blist))]((x ,l)))
        )
    )

(* ================ STREAMS ==================== *)

Type stream = rec(t, (bool * lazy(t)))
Declare push =
    fun (x : bool) -> ret (
        fun (s : lazy(stream)) -> ret (
            fold[stream]((x, s))
        )
    )
Declare pop = fun (s : stream) ->
    let* c = unfold(s) in
    lets (x, rest) = c in
    let* next = force(rest) in
    ret((x, next))

Declare take = FIX[(nat -> (stream -> blist))](take,
ret(
    fun (n : nat) -> ret (
        fun (s : stream) ->
            let* n' = unfold(n) in
            case n' of
                left(_) -> ret(nil)
                right(e) ->
                    let* s' = (pop s) in
                    lets (x, rest) = s' in
                    let* res = C((_ rest), C((_ e), take)) in
                    C((_ res), (cons x))
        )
    )
)

Declare 0s = FIX[stream](0s,
    C((_ lazy(0s)), (push false))
)

Declare map = FIX[((bool -> bool) -> (stream -> stream))](map,
ret(
    fun (f : (bool -> bool)) -> ret(
        fun (s : stream) ->
            let* s' = (pop s) in
            lets (x, rest) = s' in
            let* rec_map = C((_ f), map) in
            let* push_new = C((push _), (f x)) in
            (push_new lazy((rec_map rest)))
    )
))

Declare merge = FIX[(stream -> (stream -> stream))](merge,
ret (
    fun (s1 : stream) -> ret (
        fun (s2 : stream) ->
            let* s1' = (pop s1) in
            let* s2' = (pop s2) in
            lets (x1, rest1) = s1' in
            lets (x2, rest2) = s2' in
            let* frec' = C((_ rest1), merge) in
            let* push' = (push x2) in
            let* push''' = (push x1) in
            (push''' lazy((push' lazy((frec' rest2)))))
    )
))

(* ========================= TESTING ======================== *)

Declare 1 = (succ 0)
Declare 2 = (succ 1)

Macro TAKE2 s = let* partial = (take 2) in (partial s)

(* take 2 0s *)
Eval TAKE2(0s)

(* map flip on 0s *)
Declare 1s =
    C((_ 0s), (map flip))

(* take 2 1s *)
Eval TAKE2(1s)

Declare alternating =
    C((_ 1s), (merge 0s))

(* take 2 alternating *)
Eval TAKE2(alternating)
