Macro C e v = let* _ = v in e (* EASY CHAINING *)

(* ================ RECURSION ==================== *)

Typemacro SELF tau = rec(t, (t -> tau))
Macro SELF [tau] expr = fold[SELF(tau)](fun (tmp : SELF(tau)) -> expr)
Macro UNROLL g =
     let* unf = unfold(g) in
     (unf . g)
Macro FIX [tau] x e =
     UNROLL(SELF[tau](SUBSTITUTE(x, UNROLL(tmp), e)))

(* ================== NAT ====================== *)

Type nat = rec(t, (1 + t))
Declare zero = fold[nat](left[(1 + nat)](()))
Declare succ = fun (x : nat) -> ret (fold[nat](right[(1 + nat)](x)))

(* ================== BOOL ====================== *)

Type bool = (1 + 1)
Declare true = left[bool]( () )
Declare false = right[bool]( () )

Declare flip = fun (x : bool) ->
    case x of
        left(_) (* true *) -> ret (false) (* lambdas should return computations *)
        right(_) (* false *) -> ret (true)

(* ================ BOOL LIST ================ *)

Type blist = rec(t, (1 + (bool * t)))
Declare nil = fold[blist](left[(1 + (bool * blist))](()))
Declare cons =
    fun (x : bool) -> ret (
        fun (l : blist) -> ret (
            fold[blist](right[(1 + (bool * blist))]((x ,l)))
        )
    )

(* ================ STREAMS ==================== *)

Type stream = rec(t, (bool * lazy(t)))
Declare push =
    fun (x : bool) -> ret (
        fun (s : lazy(stream)) -> ret (
            fold[stream]((x, s))
        )
    )
Declare pop = fun (s : stream) ->
    let* c = unfold(s) in
    lets (x, rest) = c in
    let* next = force(rest) in
    ret((x, next))

Declare take = FIX[(nat -> (stream -> blist))](take,
ret(
    fun (n : nat) -> ret (
        fun (s : stream) ->
            let* n' = unfold(n) in
            case n' of
                left(_) -> ret(nil)
                right(e) ->
                    let* s' = pop . s in
                    lets (x, rest) = s' in
                    let* res = C(_ . rest, C(_ . e, take)) in
                    C(_ . res, (cons . x))
        )
    )
)

Declare zeros = FIX[stream](zeros,
    C(_ . lazy(zeros), push . false)
)

Declare map = FIX[((bool -> bool) -> (stream -> stream))](map,
ret(
    fun (f : (bool -> bool)) -> ret(
        fun (s : stream) ->
            let* s' = pop . s in
            lets (x, rest) = s' in
            let* rec_map = C(_ . f, map) in
            let* push_new = C(push . _, f . x) in
            (push_new . lazy((rec_map . rest)))
    )
))

Declare merge = FIX[(stream -> (stream -> stream))](merge,
ret (
    fun (s1 : stream) -> ret (
        fun (s2 : stream) ->
            let* s1' = pop . s1 in
            let* s2' = pop . s2 in
            lets (x1, rest1) = s1' in
            lets (x2, rest2) = s2' in
            let* frec' = C(_ . rest1, merge) in
            let* push' = (push . x2) in
            let* push''' = (push . x1) in
            (push''' . lazy((push' . lazy((frec' . rest2)))))
    )
))

(* ========================= TESTING ======================== *)

Declare one = (succ . zero)
Declare two = C(succ . _, one)

Macro TAKETWO s =
    let* two' = two in
    let* f' = C(_ . two', take) in
    C(f' . _, s)

(* take 2 zeros *)
Eval TAKETWO(zeros)

(* map flip on zeros *)
Declare ones =
    let* zeros' = zeros in
    C(_ . zeros', C(_ . flip, map))

(* take 2 ones *)
Eval TAKETWO(ones)

Declare alternating =
    let* zeros' = zeros in
    let* ones' = ones in
    C(_ . ones', C(_ . zeros', merge))

(* take 2 alternating *)
Eval TAKETWO(alternating)
